<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Threat Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <!-- Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0/dist/tf.min.js"></script>



  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Poppins', sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
    }
   h1 {
  color: #ffd700; /* Ø°Ù‡Ø¨ÙŠ Ù„Ø§Ù…Ø¹ */
  margin-bottom: 20px;
  font-size: 28px;
}

#threatChart {
  height: 250px; /* Ø£Ùˆ Ø£ÙŠ Ù‚ÙŠÙ…Ø© ØªÙ†Ø§Ø³Ø¨Ùƒ Ù…Ø«Ù„ 150px Ø£Ùˆ 250px */
  max-height: 250px;
}


    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    input, select, button {
      background: #161b22;
      color: #ffffff;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 14px;
    }
    .table-container {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #30363d;
      border-radius: 6px;
      margin-bottom: 30px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid #30363d;
    }
   th {
  background-color: #222;       /* ØºØ§Ù…Ù‚ Ø£ÙƒØ«Ø± Ù„ÙŠØ¨Ø±Ø² Ø§Ù„Ø°Ù‡Ø¨ */
  color: #ffd700;               /* Ù„ÙˆÙ† Ø°Ù‡Ø¨ÙŠ Ù„Ø§Ù…Ø¹ */
  font-weight: bold;
  font-size: 16px;
}


td {
  color: #ffffff;      /* Ø§Ù„Ù†Øµ Ø£Ø¨ÙŠØ¶ */
  padding: 12px 10px;
  border: 1px solid #333;
  font-size: 15px;
}


    tr:nth-child(even) {
      background-color: #1f2937;
    }

    #threatChart {
      max-width: 100%;
      margin-bottom: 40px;
    }

    form {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    button {
      cursor: pointer;
      background-color: #238636;
      color: white;
      transition: background 0.3s;
    }
    button:hover {
      background-color: #2ea043;
    }

    .icon {
      color: #58a6ff;
      margin-right: 5px;
    }

    @media (max-width: 600px) {
      .filters, form {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>

<div style="margin-top: 30px;">
  <h3>Manual Log Analyzer (AI)</h3>
  <input type="text" id="log-input" placeholder="Enter raw log line..." style="width: 60%; padding: 10px;" />
  <button id="generate-btn" style="padding: 10px 15px; background-color:#007bff;">Generate</button>
  <button id="analyze-btn" style="padding: 10px 15px;">Analyze</button>
</div>


<body>

  <h1><i class="fas fa-shield-alt icon"></i> Threat Monitoring Dashboard</h1>

  <div class="filters">
    <input type="text" id="filterIP" placeholder="ğŸ” Filter by IP">
    <select id="filterType">
      <option value="">All Threats</option>
      <option value="malware detected">Malware</option>
      <option value="scan attempt">Scan</option>
      <option value="attack vector">Attack</option>
    </select>
  </div>

  <div class="table-container">
    <table>
      <thead>
        <tr>
          <th>Timestamp</th>
          <th>IP Address</th>
          <th>Method</th>
          <th>Threat Type</th>
          <th>Action Taken</th>

        </tr>
      </thead>
      <tbody id="logTableBody"></tbody>
    </table>
  </div>

  <canvas id="threatChart" height="120"></canvas>

  <h3 style="margin-top: 20px;">Add Fake Threat</h3>
  <form id="addForm">
    <input type="text" name="ip" placeholder="IP" required>
    <select name="method"><option>GET</option><option>POST</option></select>
    <select name="type">
      <option value="malware detected">Malware</option>
      <option value="scan attempt">Scan</option>
      <option value="attack vector">Attack</option>
    </select>
    <button type="submit"><i class="fas fa-plus-circle icon"></i> Add</button>
  </form>

  <script>
    let allLogs = [];
    let chartRef = null;

    // Ø§Ø³ØªØ¨Ø¯Ù„ Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø¨Ù‡Ø§
async function fetchCSVFromGitHub() {
  try {
    // Ù†Ø¬ÙŠØ¨ Ø§Ù„Ù…Ù„Ù Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ± Ù…Ø¨Ø§Ø´Ø±Ø© (Ø§Ù„Ù€ endpoint Ø§Ù„Ù„ÙŠ Ø¹Ù…Ù„Ù†Ø§Ù‡)
    const url = `/api/threats?_=${Date.now()}`;
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) {
      console.error('Failed to fetch /api/threats', res.status);
      return [];
    }
    const text = await res.text();

    if (!text || text.trim().length === 0) return [];

    // Ø¨Ø³ÙŠØ· Ù„ÙƒÙ† ØµÙ„Ø¨: parser ÙŠØ­ØªØ±Ù… Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ù‚ØªØ¨Ø³Ø© Ø§Ù„ØªÙŠ ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ÙÙˆØ§ØµÙ„
    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(Boolean);
      if (lines.length <= 1) return [];
      const rows = [];
      // ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ù‡ÙŠØ¯Ø±
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        const cols = [];
        let cur = '';
        let inQuotes = false;
        for (let j = 0; j < line.length; j++) {
          const ch = line[j];
          if (ch === '"' ) {
            // toggle quote unless it's an escaped double-quote ""
            if (line[j+1] === '"') {
              cur += '"';
              j++; // skip escaped quote
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }
          if (ch === ',' && !inQuotes) {
            cols.push(cur);
            cur = '';
            continue;
          }
          cur += ch;
        }
        cols.push(cur);
        rows.push(cols);
      }
      return rows;
    }

    const rows = parseCSV(text);

    // Ù†Ø¹ÙŠØ¯ Ù…ØµÙÙˆÙØ© Ù…Ù† Ø§Ù„ÙƒØ§Ø¦Ù†Ø§Øª Ù…Ø¹ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    return rows
      .map(parts => {
        // Ø¨Ø¹Ø¶ Ø§Ù„ØµÙÙˆÙ Ù‚Ø¯ ØªØ­ØªÙˆÙŠ Ø£Ø¹Ù…Ø¯Ø© Ø¥Ø¶Ø§ÙÙŠØ© Ø£Ùˆ Ø£Ù‚Ù„Ø› Ù†ØªØ¹Ø§Ù…Ù„ Ø¨Ø­Ø°Ø±
        const timestamp = (parts[0] || '').trim();
        const ip = (parts[1] || '').trim();
        const method = (parts[2] || '').trim();
        // threatType Ù‚Ø¯ ÙŠÙƒÙˆÙ† ÙÙŠ Ø£Ø¬Ø²Ø§Ø¡ Ù…ØªØ¹Ø¯Ø¯Ø© Ø¥Ø°Ø§ Ù„Ù… ØªÙØºÙ„Ù‚ Ø§Ù„Ø§Ù‚ØªØ¨Ø§Ø³Ø§Øª Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­ØŒ Ù„Ø°Ù„Ùƒ Ù†Ø¬Ù…Ø¹ ÙƒÙ„ Ù…Ø§ Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…ÙˆØ¯ 3 ÙˆØ¹Ù…ÙˆØ¯ Ù‚Ø¨Ù„ Ø§Ù„Ø£Ø®ÙŠØ±
        const threatType = (parts[3] || '').trim();
        // action Ù‚Ø¯ ÙŠÙƒÙˆÙ† Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø±Ø§Ø¨Ø¹ Ø£Ùˆ Ø§Ù„Ø®Ø§Ù…Ø³ Ø­Ø³Ø¨ Ø§Ù„Ù‡ÙŠØ¯Ø±ØŒ Ù†Ø­Ø§ÙˆÙ„ Ø£Ø®Ø° Ø§Ù„Ø¹Ù…ÙˆØ¯ Ø§Ù„Ø£Ø®ÙŠØ± ÙƒÙ€ action Ø¥Ù† ÙˆÙØ¬Ø¯
        const action = (parts.length >= 5 ? parts[4] : '') || '';
        return { timestamp, ip, method, threatType, action };
      })
      .filter(r => r.ip && r.method); // Ù†ØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ø³Ø·ÙˆØ± Ø§Ù„ÙØ§Ø±ØºØ©
  } catch (error) {
    console.error('âŒ Error loading CSV from /api/threats:', error);
    return [];
  }
}

    function renderTable(logs) {
  const tbody = document.getElementById('logTableBody');
  tbody.innerHTML = '';

  // ØªØ±ØªÙŠØ¨ logs Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ® ØªÙ†Ø§Ø²Ù„ÙŠ (Ø£Ø­Ø¯Ø« ØªØ§Ø±ÙŠØ® Ø£ÙˆÙ„Ø§Ù‹)
  logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

  logs.forEach(log => {
    const actionDisplay = log.action || 'N/A';
    let color = 'gray';
    if (actionDisplay === 'block') color = 'red';
    else if (actionDisplay === 'alert') color = 'gold';

    tbody.innerHTML += `
      <tr>
        <td>${log.timestamp}</td>
        <td>${log.ip}</td>
        <td>${log.method}</td>
        <td>${log.threatType}</td>
        <td style="font-weight:bold;">
          ${actionIcon(log.action)}
        </td>
      </tr>
    `;
  });
}

    function drawThreatChart(logs) {
      const filtered = filterLogs(logs);
      const threatCounts = {};
      filtered.forEach(t => {
        threatCounts[t.threatType] = (threatCounts[t.threatType] || 0) + 1;
      });

      const labels = Object.keys(threatCounts);
      const dataValues = Object.values(threatCounts);
      const ctx = document.getElementById('threatChart').getContext('2d');

      if (chartRef) chartRef.destroy();

      chartRef = new Chart(ctx, {
        type: 'bar',
        data: {
          labels,
          datasets: [{
            label: 'Threat Count',
            data: dataValues,
            backgroundColor: ['#d32f2f', '#fbc02d', '#1976d2'],
            borderRadius: 8
          }]
        },
        options: {
          plugins: {
            legend: { labels: { color: '#fff' } },
            title: {
              display: true,
              text: 'Threat Type Statistics',
              color: '#58a6ff'
            }
          },
          scales: {
            x: { ticks: { color: '#ccc' }, grid: { display: false } },
            y: { beginAtZero: true, ticks: { color: '#ccc' }, grid: { color: '#333' } }
          }
        }
      });
    }

    async function updateDashboard() {
      const logs = await fetchCSVFromGitHub();
      allLogs = logs;
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    }

    document.getElementById('filterIP').addEventListener('input', () => {
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    });

    document.getElementById('filterType').addEventListener('change', () => {
      renderTable(filterLogs(allLogs));
      drawThreatChart(allLogs);
    });

    document.getElementById('addForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = e.target;
      const newThreat = {
        ip: form.ip.value,
        method: form.method.value,
        threatType: form.type.value
      };

      const res = await fetch('/api/add-threat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newThreat)
      });

      if (res.ok) {
        form.reset();
        updateDashboard();
      } else {
        alert('âŒ Failed to send threat to server.');
      }
    });

    updateDashboard();
    // ØªØ­Ø¯ÙŠØ« ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙƒÙ„ 5 Ø«ÙˆØ§Ù†ÙŠ (5000 Ù…Ù„Ù„ÙŠ Ø«Ø§Ù†ÙŠØ©)
setInterval(updateDashboard, 5000);



document.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Error attempting fullscreen: ${err.message}`);
    });
  }
});



function actionIcon(action) {
  if (!action) return '<span style="color:gray;">â„¹ï¸</span> â„¹ï¸ INFO';
  switch (action.toLowerCase()) {
    case 'blocked':
    case 'block':
      return '<span style="color:red;">âŒ</span> BLOCKED';
    case 'suspicious':
    case 'alerted':
    case 'alert':
      return '<span style="color:orange;">âš ï¸</span> ALERTED';
    case 'allowed':
    case 'logged':
    case 'log':
    case 'auto':  // <-- Ø£Ø¶ÙØª Ù‡Ø°Ù‡ Ø§Ù„Ø­Ø§Ù„Ø©
      return '<span style="color:#1e90ff;">ğŸ›¡ï¸ğŸ”’</span> SECURE';
    case 'normal visit':
      return '<span style="color:#1e90ff;">ğŸ›¡ï¸ğŸ”’</span> NORMAL VISIT';
    case 'ignore':
    case 'ignored':
      return '<span style="color:gray;">â„¹ï¸</span> IGNORED';
    default:
      return '<span style="color:gray;">â„¹ï¸</span> INFO';
  }
}



 const MODEL_URL = './model.json';
  const ACTIONS = ['block', 'alert', 'ignore'];
  const LEARNING_RATE = 0.01;

  function encodeState(log) {
    const ipSuspicion = log.includes('192.168') ? 0 : 1;
    const requestType = log.includes('POST') ? 1 : 0;
    const keywordDetected = /(malware|attack|scan)/i.test(log) ? 1 : 0;
    return [ipSuspicion, requestType, keywordDetected, 0, 0, 0, 0, 0];
  }

  async function loadModel() {
    const model = await tf.loadLayersModel(MODEL_URL);
    model.compile({
      optimizer: tf.train.adam(LEARNING_RATE),
      loss: 'categoricalCrossentropy',
    });
    return model;
  }

  async function selectAction(model, state) {
    const input = tf.tensor2d([state]);
    const prediction = model.predict(input);
    const actionIdx = (await prediction.argMax(1).data())[0];
    return ACTIONS[actionIdx];
  }

  function executeAction(action, log) {
    const line = document.createElement('div');
    const resultBox = document.getElementById('logTableBody');
    switch (action) {
      case 'block':
        line.style.color = 'red';
        line.textContent = `[BLOCKED] ${log}`;
        break;
      case 'alert':
        line.style.color = 'orange';
        line.textContent = `[ALERT] ${log}`;
        break;
      default:
        line.style.color = 'gray';
        line.textContent = `[IGNORED] ${log}`;
    }
    resultBox.appendChild(line);
  }

  document.getElementById('analyze-btn')?.addEventListener('click', async () => {
    const logInput = document.getElementById('log-input')?.value.trim();
    if (!logInput) return;
    const model = await loadModel();
    analyzeLog(logInput, model);
  });

  async function analyzeLog(rawLog, model) {
  const state = encodeState(rawLog);
  const action = await selectAction(model, state);

  const parts = rawLog.split(' ');
  const timestamp = parts[0] || new Date().toISOString();
  const ip = parts[1] || '0.0.0.0';
  const method = parts[2] || 'GET';

  // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¬ÙˆÙ… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ù…Ù† rawLog
  const attackTypes = ['malware detected', 'scan attempt', 'attack vector'];
  const matchedType = attackTypes.find(type => rawLog.toLowerCase().includes(type)) || 'unknown threat';

  const analyzedLog = {
    timestamp,
    ip,
    method,
    threatType: matchedType,
    action
  };

  prependLogToTable(analyzedLog);
  allLogs.unshift(analyzedLog);
  drawThreatChart(allLogs);
}




  // ØªÙˆÙ„ÙŠØ¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù„Ù„Ù‡Ø¬Ù…Ø§Øª
const ATTACK_TYPES = [
  { type: 'malware detected', methods: ['POST', 'GET'], keywords: ['Trojan.exe', 'virus_payload', 'malicious.exe'] },
  { type: 'scan attempt', methods: ['GET'], keywords: ['nmap scan', 'port scan', 'banner grab'] },
  { type: 'attack vector', methods: ['POST'], keywords: ['SQL injection', 'XSS payload', 'buffer overflow'] }
];

function getRandomIP() {
  return `${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}.${Math.floor(Math.random() * 256)}`;
}

function generateRandomLog() {
  const attack = ATTACK_TYPES[Math.floor(Math.random() * ATTACK_TYPES.length)];
  const ip = getRandomIP();
  const method = attack.methods[Math.floor(Math.random() * attack.methods.length)];
  const keyword = attack.keywords[Math.floor(Math.random() * attack.keywords.length)];
  const threatType = attack.type;
  const timestamp = new Date().toISOString();

  return {
    timestamp,
    ip,
    method,
    threatType,
    keyword,
    raw: `${timestamp} ${ip} ${method} ${threatType} ${keyword}`
  };
}

// Ø¹Ù†Ø¯ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø± Generate
document.getElementById('generate-btn').addEventListener('click', async () => {
  const log = generateRandomLog();
  document.getElementById('log-input').value = log.raw;

  const model = await loadModel();
  const state = encodeState(log.raw);
  const action = await selectAction(model, state);

  const analyzedLog = {
    timestamp: log.timestamp,
    ip: log.ip,
    method: log.method,
    threatType: log.threatType, // âœ… Ù‡Ø°Ø§ Ù…ÙˆØ¬ÙˆØ¯ Ù…Ø³Ø¨Ù‚Ù‹Ø§ Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­
    action
  };

  prependLogToTable(analyzedLog);
  allLogs.unshift(analyzedLog);
  drawThreatChart(allLogs);
});


function threatTypeIcon(threatType) {
  const type = threatType.trim().toLowerCase();

  if (type.includes('malware')) return 'âŒ BLOCKED';
  if (type.includes('scan')) return 'âœ… LOGGED';
  if (type.includes('attack')) return 'âš ï¸ ALERTED';

  return 'â„¹ï¸ INFO';
}

function prependLogToTable(log) {
  const tbody = document.getElementById('logTableBody');
  const newRow = document.createElement('tr');

  // Ù†Ø³ØªØ®Ø¯Ù… action ÙÙ‚Ø·ØŒ ÙˆØ¥Ø°Ø§ Ù„Ù… ØªÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø© Ù†Ø¹Ø±Ø¶ Ø±Ø³Ø§Ù„Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
  const action = log.action ? log.action.toLowerCase() : 'normal visit';

  newRow.innerHTML = `
    <td>${log.timestamp}</td>
    <td>${log.ip}</td>
    <td>${log.method}</td>
    <td style="font-weight:bold;">${log.threatType}</td>
    <td style="font-weight:bold;">${actionIcon(action)}</td>
  `;
  tbody.prepend(newRow);
}


  </script>
</body>
</html>
