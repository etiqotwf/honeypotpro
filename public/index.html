<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Threat Dashboard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.4.0/dist/tf.min.js"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Poppins', sans-serif;
      background: #0d1117;
      color: #c9d1d9;
      padding: 20px;
    }
    h1 { color: #ffd700; margin-bottom: 20px; font-size: 28px; }
    #threatChart { height: 250px; max-height: 250px; margin-bottom: 40px; }
    .filters { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px; }
    input, select, button { background: #161b22; color: #ffffff; border: 1px solid #30363d; border-radius: 6px; padding: 8px 12px; font-size: 14px; }
    .table-container { max-height: 300px; overflow-y: auto; border: 1px solid #30363d; border-radius: 6px; margin-bottom: 30px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #30363d; }
    th { background-color: #222; color: #ffd700; font-weight: bold; font-size: 16px; }
    td { color: #ffffff; padding: 12px 10px; border: 1px solid #333; font-size: 15px; }
    tr:nth-child(even) { background-color: #1f2937; }
    form { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    button { cursor: pointer; background-color: #238636; color: white; transition: background 0.3s; }
    button:hover { background-color: #2ea043; }
    .icon { color: #58a6ff; margin-right: 5px; }
    @media (max-width: 600px) { .filters, form { flex-direction: column; align-items: stretch; } }
  </style>
</head>
<body>

<h1><i class="fas fa-shield-alt icon"></i> Threat Monitoring Dashboard</h1>

<div style="margin-top: 30px;">
  <h3>Manual Log Analyzer (AI)</h3>
  <input type="text" id="log-input" placeholder="Enter raw log line..." style="width: 60%; padding: 10px;" />
  <button id="generate-btn" style="padding: 10px 15px; background-color:#007bff;">Generate</button>
  <button id="analyze-btn" style="padding: 10px 15px;">Analyze</button>
</div>

<div class="filters">
  <input type="text" id="filterIP" placeholder="ğŸ” Filter by IP">
  <select id="filterType">
    <option value="">All Threats</option>
    <option value="malware detected">Malware</option>
    <option value="scan attempt">Scan</option>
    <option value="attack vector">Attack</option>
  </select>
</div>

<div class="table-container">
  <table>
    <thead>
      <tr>
        <th>Timestamp</th>
        <th>IP Address</th>
        <th>Method</th>
        <th>Threat Type</th>
        <th>Action Taken</th>
      </tr>
    </thead>
    <tbody id="logTableBody"></tbody>
  </table>
</div>

<canvas id="threatChart" height="120"></canvas>

<h3 style="margin-top: 20px;">Add Fake Threat</h3>
<form id="addForm">
<input type="text" name="ip" placeholder="IP">
  <select name="method"><option>GET</option><option>POST</option></select>
  <select name="type">
    <option value="malware detected">Malware</option>
    <option value="scan attempt">Scan</option>
    <option value="attack vector">Attack</option>
  </select>
  <button type="submit"><i class="fas fa-plus-circle icon"></i> Add</button>
</form>

<script>
let allLogs = [];
let chartRef = null;

// Ù‚Ø±Ø§Ø¡Ø© CSV Ù…Ù† ÙÙˆÙ„Ø¯Ø± logs
async function fetchCSVFromLogs() {
  try {
    const res = await fetch(`logs/threats.csv?_=${Date.now()}`, { cache: "no-store" });
    if (!res.ok) return [];
    const text = await res.text();
    if (!text.trim()) return [];
    const lines = text.split(/\r?\n/).filter(Boolean);
    const rows = [];
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/).map(s => s.replace(/^"|"$/g,''));
      if(cols.length >= 3) rows.push(cols);
    }
    return rows.map(parts => ({
      timestamp: (parts[0]||'').trim(),
      ip: (parts[1]||'').trim(),
      method: (parts[2]||'').trim(),
      threatType: (parts[3]||'').trim(),
      action: (parts[4]||'').trim() || ''
    })).filter(r=>r.ip && r.method);
  } catch (err) {
    console.error('Error loading CSV:', err);
    return [];
  }
}

function filterLogs(logs) {
  const ipFilter = document.getElementById('filterIP').value.toLowerCase();
  const typeFilter = document.getElementById('filterType').value.toLowerCase();
  return logs.filter(l =>
    (!ipFilter || l.ip.toLowerCase().includes(ipFilter)) &&
    (!typeFilter || l.threatType.toLowerCase() === typeFilter)
  );
}

function renderTable(logs) {
  const tbody = document.getElementById('logTableBody');
  tbody.innerHTML = '';
  logs.sort((a,b)=> new Date(b.timestamp)-new Date(a.timestamp));
  logs.forEach(log => {
    tbody.innerHTML += `
      <tr>
        <td>${log.timestamp}</td>
        <td>${log.ip}</td>
        <td>${log.method}</td>
        <td style="font-weight:bold;">${log.threatType}</td>
        <td style="font-weight:bold;">${actionIcon(log.action)}</td>
      </tr>
    `;
  });
}

function drawThreatChart(logs) {
  const filtered = filterLogs(logs);
  const threatCounts = {};
  filtered.forEach(t => { threatCounts[t.threatType] = (threatCounts[t.threatType]||0)+1; });
  const labels = Object.keys(threatCounts);
  const dataValues = Object.values(threatCounts);
  const ctx = document.getElementById('threatChart').getContext('2d');
  if(chartRef) chartRef.destroy();
  chartRef = new Chart(ctx,{
    type:'bar',
    data:{ labels, datasets:[{ label:'Threat Count', data:dataValues, backgroundColor:['#d32f2f','#fbc02d','#1976d2'], borderRadius:8 }]},
    options:{ plugins:{ legend:{labels:{color:'#fff'}}, title:{display:true,text:'Threat Type Statistics',color:'#58a6ff'}}, scales:{ x:{ticks:{color:'#ccc'},grid:{display:false}}, y:{beginAtZero:true,ticks:{color:'#ccc'},grid:{color:'#333'}} } }
  });
}

async function updateDashboard() {
  allLogs = await fetchCSVFromLogs();
  renderTable(filterLogs(allLogs));
  drawThreatChart(allLogs);
}

document.getElementById('filterIP').addEventListener('input',()=>{ renderTable(filterLogs(allLogs)); drawThreatChart(allLogs); });
document.getElementById('filterType').addEventListener('change',()=>{ renderTable(filterLogs(allLogs)); drawThreatChart(allLogs); });

function actionIcon(action) {
  if(!action) return '<span style="color:gray;">â„¹ï¸</span> INFO';
  switch(action.toLowerCase()){
    case 'blocked': case 'block': return '<span style="color:red;">âŒ</span> BLOCKED';
    case 'suspicious': case 'alerted': case 'alert': return '<span style="color:orange;">âš ï¸</span> ALERTED';
    case 'allowed': case 'logged': case 'log': return '<span style="color:#1e90ff;">ğŸ›¡ï¸ğŸ”’</span> SECURE';
    case 'normal visit': return '<span style="color:#1e90ff;">ğŸ›¡ï¸ğŸ”’</span> NORMAL VISIT';
    case 'ignore': case 'ignored': return '<span style="color:gray;">â„¹ï¸</span> IGNORED';
    default:
      // Ù„Ùˆ action Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø£ÙŠ Ù†Øµ Ø«Ø§Ù†ÙŠ Ù†Ø¹Ø±Ø¶Ù‡ ÙƒÙ…Ø§ Ù‡Ùˆ
      return `<span style="color:red;">âŒ</span> ${action.toUpperCase()}`;
  }
}

updateDashboard();
setInterval(updateDashboard,60000);

document.getElementById('addForm').addEventListener('submit', async e => {
  e.preventDefault();
  const f = e.target;

  // Ù„Ùˆ ÙØ§Ø¶ÙŠ â†’ Ù‡Ù†Ø¹Ù…Ù„ IP Ø¹Ø´ÙˆØ§Ø¦ÙŠ ÙˆÙ‡Ø¬ÙˆÙ… Ø¹Ø´ÙˆØ§Ø¦ÙŠ
  let ip = f.ip.value.trim();
  let method = f.method.value;
  let type = f.type.value;

  if (!ip) {
    // ØªÙˆÙ„ÙŠØ¯ IP Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    ip = `${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}`;

    // Ø§Ø®ØªÙŠØ§Ø± Ø·Ø±ÙŠÙ‚Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
    const methods = ["GET", "POST"];
    method = methods[Math.floor(Math.random() * methods.length)];

    // Ø§Ø®ØªÙŠØ§Ø± ØªÙ‡Ø¯ÙŠØ¯ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
    const types = ["malware detected", "scan attempt", "attack vector"];
    type = types[Math.floor(Math.random() * types.length)];
  }

  const newThreat = {
    timestamp: new Date().toISOString(),
    ip,
    method,
    threatType: type,
    action: "added"
  };


  // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯ ÙØ¹Ù„ÙŠØ§Ù‹ Ù„Ù„Ø³ÙŠØ±ÙØ± Ù„ÙŠÙƒØªØ¨ ÙÙŠ threats.csv
  await fetch("/add-threat", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(newThreat)
  });

  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯ Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© ÙÙ‚Ø·
  allLogs.unshift(newThreat);
  renderTable(filterLogs(allLogs));
  drawThreatChart(allLogs);

  f.reset();
});

// Fullscreen Ø¹Ù†Ø¯ Ø£ÙŠ Ù†Ù‚Ø±Ø©
document.addEventListener('click',()=>{ if(!document.fullscreenElement){ document.documentElement.requestFullscreen().catch(err=>console.error(err)); } });

// ØªÙˆÙ„ÙŠØ¯ ÙˆØªØ­Ù„ÙŠÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ
const ATTACK_TYPES=[{type:'malware detected',methods:['POST','GET'],keywords:['Trojan.exe','virus_payload','malicious.exe']},{type:'scan attempt',methods:['GET'],keywords:['nmap scan','port scan','banner grab']},{type:'attack vector',methods:['POST'],keywords:['SQL injection','XSS payload','buffer overflow']}];

function getRandomIP(){ return `${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}.${Math.floor(Math.random()*256)}`; }
function generateRandomLog(){
  const a=ATTACK_TYPES[Math.floor(Math.random()*ATTACK_TYPES.length)];
  const ip=getRandomIP();
  const method=a.methods[Math.floor(Math.random()*a.methods.length)];
  const keyword=a.keywords[Math.floor(Math.random()*a.keywords.length)];
  return { timestamp:new Date().toISOString(), ip, method, threatType:a.type, keyword, raw:`${new Date().toISOString()} ${ip} ${method} ${a.type} ${keyword}` };
}

function prependLogToTable(log){
  const tbody=document.getElementById('logTableBody');
  const action=log.action?log.action.toLowerCase():log.action; // Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù‚ÙŠÙ…Ø© ÙƒÙ…Ø§ Ù‡ÙŠ
  const newRow=document.createElement('tr');
  newRow.innerHTML=`<td>${log.timestamp}</td><td>${log.ip}</td><td>${log.method}</td><td style="font-weight:bold;">${log.threatType}</td><td style="font-weight:bold;">${actionIcon(action)}</td>`;
  tbody.prepend(newRow);
}

// Ø²Ø± Generate
document.getElementById('generate-btn').addEventListener('click', async ()=>{
  const log=generateRandomLog();
  document.getElementById('log-input').value=log.raw;
  const analyzedLog={ timestamp:log.timestamp, ip:log.ip, method:log.method, threatType:log.threatType, action:'' };
  prependLogToTable(analyzedLog);
  allLogs.unshift(analyzedLog);
  drawThreatChart(allLogs);
});

// Ø²Ø± Analyze Ù…Ø¹ TF.js
const MODEL_URL='./model.json';
const ACTIONS=['block','alert','ignore'];
const LEARNING_RATE=0.01;

function encodeState(log){
  const ipSuspicion=log.includes('192.168')?0:1;
  const requestType=log.includes('POST')?1:0;
  const keywordDetected=/(malware|attack|scan)/i.test(log)?1:0;
  return [ipSuspicion,requestType,keywordDetected,0,0,0,0,0];
}

async function loadModel(){
  const model=await tf.loadLayersModel(MODEL_URL);
  model.compile({optimizer:tf.train.adam(LEARNING_RATE), loss:'categoricalCrossentropy'});
  return model;
}

async function selectAction(model,state){
  const input=tf.tensor2d([state]);
  const prediction=model.predict(input);
  const actionIdx=(await prediction.argMax(1).data())[0];
  return ACTIONS[actionIdx];
}

async function analyzeLog(rawLog, model){
  const state=encodeState(rawLog);
  const action=await selectAction(model,state);
  const parts=rawLog.split(' ');
  const timestamp=parts[0]||new Date().toISOString();
  const ip=parts[1]||'0.0.0.0';
  const method=parts[2]||'GET';
  const attackTypes=['malware detected','scan attempt','attack vector'];
  const matchedType=attackTypes.find(t=>rawLog.toLowerCase().includes(t))||'unknown threat';
  const analyzedLog={ timestamp, ip, method, threatType:matchedType, action };
  prependLogToTable(analyzedLog);
  allLogs.unshift(analyzedLog);
  drawThreatChart(allLogs);
}

document.getElementById('analyze-btn').addEventListener('click', async ()=>{
  const rawLog=document.getElementById('log-input').value.trim();
  if(!rawLog) return;
  const model=await loadModel();
  analyzeLog(rawLog, model);
});

</script>
</body>
</html>
