<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üß† AI Honeypot Terminal</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
  :root { --accent: #00ffcc; --bg: #000; --muted: #00ffaa22; }
  *{box-sizing:border-box}
  body {
    margin: 0;
    font-family: 'Share Tech Mono', monospace;
    background: radial-gradient(circle at top left, #050505 0%, #000 70%);
    color: #00ffcc;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  header {
    background: rgba(0,255,200,0.06);
    border-bottom: 1px solid #00ffcc22;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
  }
  h1 { font-size:1.2rem; margin:0; color:#00ffee; }
  #status { font-size:0.9rem; color:#aaffff; display:flex; align-items:center; gap:8px; }
  .status-dot { width:10px;height:10px;border-radius:50%;background:#ff4444;box-shadow:0 0 8px #ff4444; animation:pulse 1.5s infinite; }
  .status-dot.connected { background:#44ff88; box-shadow:0 0 10px #44ff8855; }
  @keyframes pulse {0%,100%{opacity:.7;transform:scale(1)}50%{opacity:1;transform:scale(1.3)}}
  #controls { display:flex; gap:8px; align-items:center; }
  button {
    background: rgba(0,255,170,0.07);
    border: 1px solid rgba(0,255,170,0.18);
    color: var(--accent);
    padding: 8px 12px;
    border-radius:6px;
    cursor:pointer;
  }
  button:hover { box-shadow:0 0 8px rgba(0,255,170,0.06); transform:translateY(-1px); }
  #startAttack { background:#00aa66; border-color:#008844; color:#fff; }
  #logContainer { flex:1; overflow:auto; padding:14px; color:#d1fff5; text-shadow:0 0 5px #00ffee55; font-size:0.95rem; }
  .line { margin:4px 0; white-space:pre-wrap; }
  .attack { color:#ff8888; font-weight:600; }
  .system { color:#66ccff; }
  footer { background: rgba(0,255,200,0.03); text-align:center; padding:6px; font-size:0.86rem; color:#00ffee; }
  #infoBar { display:flex; gap:10px; align-items:center; color:#cffff0; }
  #ngrokUrl { font-size:0.85rem; color:#ffdca3; overflow:hidden; text-overflow:ellipsis; max-width:420px; direction:ltr; }
  @media (max-width:640px){
    header { flex-direction:column; align-items:stretch; gap:8px; }
    #controls { flex-wrap:wrap; justify-content:flex-start; }
    #ngrokUrl { max-width:220px; }
  }
</style>
</head>
<body>
<header>
  <div style="display:flex;align-items:center;gap:12px">
    <h1>üß† AI Honeypot Command Center</h1>
    <div id="infoBar">
      <div id="status"><span class="status-dot" id="dot"></span><span id="statusText">Disconnected</span></div>
      <div id="ngrokUrl">ngrok: <span id="ngrokVal">waiting...</span></div>
    </div>
  </div>

  <div id="controls">
    <!-- ÿ≤ÿ± Start SSE ÿ£ŸèŸÑÿ∫Ÿä ŸáŸÜÿß (ŸÑŸÖ ŸäÿπÿØ ŸÖŸàÿ¨ŸàÿØŸãÿß) -->
    <button id="stopBtn">‚è∏ Stop SSE</button>
    <button id="clearBtn">üóë Clear Log</button>
    <button id="copyBtn">üìã Copy Log</button>
    <button id="startAttack">üöÄ Start ngrok & Attack</button>
  </div>
</header>

<div id="logContainer" aria-live="polite"></div>

<footer>üíª Honeypot AI Terminal ‚Äî Monitoring cyber threats in real-time</footer>

<script>
/* -------------------------------------------
   JavaScript for SSE and UI buttons
   Now: Start ngrok & Attack does both:
        - start SSE (if not started)
        - request ngrok URL and open it
------------------------------------------- */
const stopBtn = document.getElementById('stopBtn');
const clearBtn = document.getElementById('clearBtn');
const copyBtn = document.getElementById('copyBtn');
const startAttackBtn = document.getElementById('startAttack');

const logContainer = document.getElementById('logContainer');
const statusText = document.getElementById('statusText');
const dot = document.getElementById('dot');
const ngrokVal = document.getElementById('ngrokVal');

let es = null;
let isAutoScroll = true;
const MAX_LINES = 5000;

function appendLine(text, cls = '') {
  const el = document.createElement('div');
  el.className = 'line ' + cls;
  el.textContent = text;
  logContainer.appendChild(el);

  while (logContainer.children.length > MAX_LINES) {
    logContainer.removeChild(logContainer.firstChild);
  }

  if (isAutoScroll) logContainer.scrollTop = logContainer.scrollHeight;
}

function setConnected(connected) {
  if (connected) {
    statusText.textContent = 'Connected';
    dot.classList.add('connected');
  } else {
    statusText.textContent = 'Disconnected';
    dot.classList.remove('connected');
  }
}
// startSSE now returns Promise that resolves on open
function startSSE() {
  if (es) {
    appendLine('[System] SSE already running', 'system');
    return Promise.resolve();
  }

  return new Promise((resolve, reject) => {
    try {
      es = new EventSource('/events');

      // ---- ŸÖÿ≥ÿ™ŸÖÿπŸàŸÜ ŸÑŸÑÿ£ÿ≠ÿØÿßÿ´ ÿßŸÑŸÖÿÆÿµÿµÿ© ÿßŸÑÿ™Ÿä Ÿäÿ±ÿ≥ŸÑŸáÿß ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± ----
      es.addEventListener('line', (e) => {
        try {
          const parsed = JSON.parse(e.data);
          const msg = parsed && (parsed.msg || parsed.message) ? (parsed.msg || parsed.message) : parsed;
          appendLine(String(msg), 'line');
        } catch {
          appendLine(e.data, 'line');
        }
      });

      es.addEventListener('system', (e) => {
        try {
          const parsed = JSON.parse(e.data);
          const msg = parsed && (parsed.msg || parsed.message) ? (parsed.msg || parsed.message) : parsed;
          appendLine(String(msg), 'system');
        } catch {
          appendLine(e.data, 'system');
        }
      });

      es.addEventListener('attack', (e) => {
        try {
          const parsed = JSON.parse(e.data);
          const msg = parsed && (parsed.msg || parsed.message) ? (parsed.msg || parsed.message) : parsed;
          appendLine(String(msg), 'attack');
        } catch {
          appendLine(e.data, 'attack');
        }
      });

      es.addEventListener('ngrok', (e) => {
        try {
          const parsed = JSON.parse(e.data);
          const url = parsed?.url || parsed?.serverUrl || e.data;
          ngrokVal.textContent = String(url);
          appendLine(`[ngrok-event] ${url}`, 'system');
        } catch {
          ngrokVal.textContent = e.data;
          appendLine(`[ngrok-event] ${e.data}`, 'system');
        }
      });

      // ---- ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿßŸÅÿ™ÿ±ÿßÿ∂Ÿäÿ© ÿπÿ®ÿ± data: ----
      es.onmessage = (evt) => {
        // evt.data ŸÇÿØ ŸäŸÉŸàŸÜ JSON-stringified object { type, msg } ÿ£Ÿà ŸÖÿ¨ÿ±ÿØ ŸÜÿµ
        try {
          const parsed = JSON.parse(evt.data);

          if (parsed && parsed.type) {
            // ŸÑŸà ÿßŸÑÿ≥Ÿäÿ±ŸÅÿ± Ÿäÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿµŸäÿ∫ÿ© ÿßŸÑŸÖŸàÿ≠ÿØÿ© { type, msg }
            if (parsed.type === 'ngrok' && parsed.url) {
              ngrokVal.textContent = parsed.url;
              appendLine(`[ngrok] ${parsed.url}`, 'system');
              return;
            }
            if (parsed.type === 'attack') { appendLine(parsed.msg || evt.data, 'attack'); return; }
            if (parsed.type === 'line') { appendLine(parsed.msg || evt.data, 'line'); return; }
            if (parsed.type === 'system') { appendLine(parsed.msg || evt.data, 'system'); return; }
            // fallback: ŸÑŸà ŸÜŸàÿπ ÿ∫Ÿäÿ± ŸÖÿπÿ±ŸàŸÅ ÿßÿπÿ±ÿ∂ ÿßŸÑÿ±ÿ≥ÿßŸÑÿ© ŸÉÿßŸÖŸÑÿ©
            appendLine(JSON.stringify(parsed), 'line');
            return;
          }

          // ŸÑŸà ŸÖÿ¥ ŸÅŸä ÿ≠ŸÇŸÑ typeÿå ÿßŸÅÿ™ÿ±ÿ∂ ÿ£ŸÜ evt.data ŸáŸà ŸÜÿµ ÿπÿßÿØŸä
          appendLine(evt.data, 'line');
        } catch (err) {
          // ŸÑŸà JSON.parse ŸÅÿ¥ŸÑ: ÿπÿ±ÿ∂ ÿßŸÑŸÜÿµ ŸÉŸÖÿß ŸáŸà
          appendLine(evt.data, 'line');
        }
      };

      es.onopen = () => {
        setConnected(true);
        appendLine('[System] SSE connection established', 'system');
        resolve();
      };

      es.onerror = (err) => {
        setConnected(false);
        appendLine('[System] SSE error occurred', 'system');
        // ŸÑÿß ŸÜÿ±ŸÅÿ∂ ŸáŸÜÿß ŸÑÿ£ŸÜ ÿ®ÿπÿ∂ ÿßŸÑÿ£ÿÆÿ∑ÿßÿ° ÿ™ÿ∏Ÿáÿ± ÿ®ÿπÿØ ŸÅÿ™ÿ≠ ÿßŸÑÿßÿ™ÿµÿßŸÑ
      };

    } catch (err) {
      appendLine('[System] Failed to start SSE: ' + err.message, 'system');
      // ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ•ŸÅÿ±ÿßÿ∫ es ŸÑŸà ŸÅÿ¥ŸÑ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°
      try { if (es) { es.close(); es = null; } } catch (_) {}
      reject(err);
    }
  });
}

function stopSSE() {
  if (!es) {
    appendLine('[System] No active SSE', 'system');
    setConnected(false);
    return;
  }
  try { es.close(); } catch {}
  es = null;
  setConnected(false);
  appendLine('[System] SSE stopped', 'system');
}

function clearLog() {
  logContainer.innerHTML = '';
  appendLine('[System] Log cleared', 'system');
}

async function copyLog() {
  try {
    let text = Array.from(logContainer.children).map(n => n.textContent).join('\n');
    await navigator.clipboard.writeText(text);
    appendLine('[System] Log copied to clipboard', 'system');
  } catch (err) {
    appendLine('[Error] Failed to copy log: ' + err.message, 'system');
  }
}

// New unified action: start SSE (if needed) then request ngrok URL and open it.
// It will NOT trigger PowerShell. It only ensures SSE + ngrok open.
async function startNgrokAndOpen() {
  appendLine('[System] Start requested: ensuring SSE then ngrok URL...', 'system');
  startAttackBtn.disabled = true;
  const prevText = startAttackBtn.textContent;
  startAttackBtn.textContent = 'Starting...';

  try {
    // 1) ensure SSE is open
    try {
      await startSSE();
    } catch (err) {
      appendLine('[Error] Failed to open SSE: ' + err.message, 'system');
      // proceed to ngrok check anyway (optional) or return; here we continue
    }

    // 2) poll /ngrok-url up to MAX_TRIES
    const MAX_TRIES = 12;
    const INTERVAL_MS = 1000;
    let tries = 0;
    let url = null;

    while (tries < MAX_TRIES && !url) {
      tries++;
      try {
        const res = await fetch('/ngrok-url');
        if (res.ok) {
          const data = await res.json();
          url = data?.serverUrl || data?.url || null;
          if (url) break;
        }
      } catch (e) {
        // ignore fetch errors, will retry
      }
      appendLine(`[System] ngrok not ready ‚Äî retry ${tries}/${MAX_TRIES}`, 'system');
      await new Promise(r => setTimeout(r, INTERVAL_MS));
    }

    if (url) {
      ngrokVal.textContent = url;
      appendLine(`[System] ngrok URL: ${url}`, 'system');
      // only the front-end opens the URL (server won't auto-open)
      window.open(url, '_blank');
    } else {
      appendLine('[Error] ngrok URL not available after retries', 'system');
    }

  } finally {
    startAttackBtn.disabled = false;
    startAttackBtn.textContent = prevText;
  }
}

stopBtn.addEventListener('click', stopSSE);
clearBtn.addEventListener('click', clearLog);
copyBtn.addEventListener('click', copyLog);
startAttackBtn.addEventListener('click', startNgrokAndOpen);

let userScrolling = false;
logContainer.addEventListener('wheel', () => { userScrolling = true; });
logContainer.addEventListener('scroll', () => {
  const atBottom = (logContainer.scrollHeight - logContainer.scrollTop - logContainer.clientHeight) < 10;
  if (atBottom) { userScrolling = false; isAutoScroll = true; }
  else if (!userScrolling) { isAutoScroll = false; }
});

window.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'l') {
    e.preventDefault();
    clearLog();
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
    if (e.shiftKey) {
      e.preventDefault();
      copyLog();
    }
  }
});

window.addEventListener('load', () => {
  appendLine('[System] Terminal UI ready', 'system');
});
</script> 

</body>
</html>
