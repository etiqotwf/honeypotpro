<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>üß† AI Honeypot Terminal</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');
  :root { --accent: #00ffcc; --bg: #000; --muted: #00ffaa22; }
  *{box-sizing:border-box}
  body {
    margin: 0;
    font-family: 'Share Tech Mono', monospace;
    background: radial-gradient(circle at top left, #050505 0%, #000 70%);
    color: #00ffcc;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  header {
    background: rgba(0,255,200,0.06);
    border-bottom: 1px solid #00ffcc22;
    padding: 10px 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 12px;
  }
  h1 { font-size:1.2rem; margin:0; color:#00ffee; }
  #status { font-size:0.9rem; color:#aaffff; display:flex; align-items:center; gap:8px; }
  .status-dot { width:10px;height:10px;border-radius:50%;background:#ff4444;box-shadow:0 0 8px #ff4444; animation:pulse 1.5s infinite; }
  .status-dot.connected { background:#44ff88; box-shadow:0 0 10px #44ff8855; }
  @keyframes pulse {0%,100%{opacity:.7;transform:scale(1)}50%{opacity:1;transform:scale(1.3)}}
  #controls { display:flex; gap:8px; align-items:center; }
  button {
    background: rgba(0,255,170,0.07);
    border: 1px solid rgba(0,255,170,0.18);
    color: var(--accent);
    padding: 8px 12px;
    border-radius:6px;
    cursor:pointer;
  }
  button:hover { box-shadow:0 0 8px rgba(0,255,170,0.06); transform:translateY(-1px); }
  #startAttack { background:#00aa66; border-color:#008844; color:#fff; }
  #logContainer { flex:1; overflow:auto; padding:14px; color:#d1fff5; text-shadow:0 0 5px #00ffee55; font-size:0.95rem; }
  .line { margin:4px 0; white-space:pre-wrap; }
  .attack { color:#ff8888; font-weight:600; }
  .system { color:#66ccff; }
  footer { background: rgba(0,255,200,0.03); text-align:center; padding:6px; font-size:0.86rem; color:#00ffee; }
  #infoBar { display:flex; gap:10px; align-items:center; color:#cffff0; }
  #ngrokUrl { font-size:0.85rem; color:#ffdca3; overflow:hidden; text-overflow:ellipsis; max-width:420px; direction:ltr; }
  @media (max-width:640px){
    header { flex-direction:column; align-items:stretch; gap:8px; }
    #controls { flex-wrap:wrap; justify-content:flex-start; }
    #ngrokUrl { max-width:220px; }
  }
</style>
</head>
<body>
<header>
  <div style="display:flex;align-items:center;gap:12px">
    <h1>üß† AI Honeypot Command Center</h1>
    <div id="infoBar">
      <div id="status"><span class="status-dot" id="dot"></span><span id="statusText">Disconnected</span></div>
      <div id="ngrokUrl">ngrok: <span id="ngrokVal">waiting...</span></div>
    </div>
  </div>

  <div id="controls">
    <button id="startBtn">‚ñ∂ Start SSE</button>
    <button id="stopBtn">‚è∏ Stop SSE</button>
    <button id="clearBtn">üóë Clear Log</button>
    <button id="copyBtn">üìã Copy Log</button>
    <button id="startAttack">üöÄ Start ngrok & Attack</button>
  </div>
</header>

<div id="logContainer" aria-live="polite"></div>

<footer>üíª Honeypot AI Terminal ‚Äî Monitoring cyber threats in real-time</footer>

<script>
/* -------------------------------------------
   JavaScript for SSE and UI buttons
------------------------------------------- */
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const clearBtn = document.getElementById('clearBtn');
const copyBtn = document.getElementById('copyBtn');
const startAttackBtn = document.getElementById('startAttack');

const logContainer = document.getElementById('logContainer');
const statusText = document.getElementById('statusText');
const dot = document.getElementById('dot');
const ngrokVal = document.getElementById('ngrokVal');

let es = null;
let isAutoScroll = true;
const MAX_LINES = 5000;

function appendLine(text, cls = '') {
  const el = document.createElement('div');
  el.className = 'line ' + cls;
  el.textContent = text;
  logContainer.appendChild(el);

  while (logContainer.children.length > MAX_LINES) {
    logContainer.removeChild(logContainer.firstChild);
  }

  if (isAutoScroll) logContainer.scrollTop = logContainer.scrollHeight;
}

function setConnected(connected) {
  if (connected) {
    statusText.textContent = 'Connected';
    dot.classList.add('connected');
  } else {
    statusText.textContent = 'Disconnected';
    dot.classList.remove('connected');
  }
}

function startSSE() {
  if (es) {
    appendLine('[System] SSE already running', 'system');
    return Promise.resolve(); // ÿ±ÿ¨ÿπ Promise ŸÑÿ£ŸÜŸÜÿß ÿ≥ŸÜÿ≥ÿ™ÿÆÿØŸÖ await ÿπŸÑŸäŸá
  }

  return new Promise((resolve, reject) => {
    try {
      es = new EventSource('/events');

      es.onopen = () => {
        setConnected(true);
        appendLine('[System] SSE connection established', 'system');
        resolve();
      };

      es.onmessage = (evt) => {
        // ŸÜŸÅÿ≥ ÿßŸÑŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ≠ÿßŸÑŸäÿ©
        try {
          const parsed = JSON.parse(evt.data);
          if (parsed && parsed.type) {
            if (parsed.type === 'ngrok' && parsed.url) {
              ngrokVal.textContent = parsed.url;
              appendLine(`[ngrok] ${parsed.url}`, 'system');
              return;
            }
            if (parsed.type === 'attack') { appendLine(parsed.msg || evt.data, 'attack'); return; }
            if (parsed.type === 'line') { appendLine(parsed.msg || evt.data, 'line'); return; }
          }
        } catch {
          appendLine(evt.data, 'line');
        }
      };

      es.onerror = (err) => {
        setConnected(false);
        appendLine('[System] SSE error occurred', 'system');
        // ŸÑÿß ŸÜÿ±ŸÅÿ∂ ŸáŸÜÿß ÿ≠ÿ™Ÿâ ŸÑÿß ŸÜŸàŸÇŸÅ ÿßŸÑŸÄ promise ÿßŸÑŸÖŸÅÿ™Ÿàÿ≠ ÿ®ÿπÿØ ÿßŸÑÿßŸÜŸÅÿ™ÿßÿ≠
      };

      es.addEventListener('ngrok', (e) => {
        try {
          const d = JSON.parse(e.data);
          ngrokVal.textContent = d.url || e.data;
          appendLine(`[ngrok-event] ${d.url || e.data}`, 'system');
        } catch {
          ngrokVal.textContent = e.data;
          appendLine(`[ngrok-event] ${e.data}`, 'system');
        }
      });

    } catch (err) {
      appendLine('[System] Failed to start SSE: ' + err.message, 'system');
      reject(err);
    }
  });
}

async function startSSEAndPS() {
  try {
    await startSSE(); // ÿßŸÑÿ¢ŸÜ ŸÜÿ∂ŸÖŸÜ ÿ£ŸÜ SSE ŸÖŸÅÿ™Ÿàÿ≠
  } catch (err) {
    appendLine('[Error] Could not open SSE: ' + err.message, 'system');
    return;
  }

  try {
    const res = await fetch('/start-powershell', { method: 'POST' });
    if (!res.ok) throw new Error('Server response not OK: ' + res.status);
    appendLine('[System] PowerShell started', 'system');
  } catch (err) {
    appendLine('[Error] Failed to start PowerShell: ' + err.message, 'system');
  }
}

startBtn.removeEventListener('click', startSSE);
startBtn.addEventListener('click', startSSEAndPS);


function stopSSE() {
  if (!es) {
    appendLine('[System] No active SSE', 'system');
    setConnected(false);
    return;
  }
  try { es.close(); } catch {}
  es = null;
  setConnected(false);
  appendLine('[System] SSE stopped', 'system');
}

function clearLog() {
  logContainer.innerHTML = '';
  appendLine('[System] Log cleared', 'system');
}

async function copyLog() {
  try {
    let text = Array.from(logContainer.children).map(n => n.textContent).join('\n');
    await navigator.clipboard.writeText(text);
    appendLine('[System] Log copied to clipboard', 'system');
  } catch (err) {
    appendLine('[Error] Failed to copy log: ' + err.message, 'system');
  }
}

async function startNgrokAndOpen() {
  appendLine('[System] Starting ngrok...', 'system');
  startAttackBtn.disabled = true;
  const prevText = startAttackBtn.textContent;
  startAttackBtn.textContent = 'Starting...';

  try {
    if (!res.ok) throw new Error('Server response not OK: ' + res.status);
    const data = await res.json();
    const url = data?.url || data?.public_url || null;

    if (url) {
      ngrokVal.textContent = url;
      appendLine(`[System] ngrok started: ${url}`, 'system');
      window.open(url, '_blank');
    } else {
      appendLine('[System] ngrok URL not returned by server', 'system');
    }
  } catch (err) {
    appendLine('[Error] Failed to start ngrok: ' + err.message, 'system');
  } finally {
    startAttackBtn.disabled = false;
    startAttackBtn.textContent = prevText;
  }
}

startBtn.addEventListener('click', startSSE);
stopBtn.addEventListener('click', stopSSE);
clearBtn.addEventListener('click', clearLog);
copyBtn.addEventListener('click', copyLog);
startAttackBtn.addEventListener('click', startNgrokAndOpen);

let userScrolling = false;
logContainer.addEventListener('wheel', () => { userScrolling = true; });
logContainer.addEventListener('scroll', () => {
  const atBottom = (logContainer.scrollHeight - logContainer.scrollTop - logContainer.clientHeight) < 10;
  if (atBottom) { userScrolling = false; isAutoScroll = true; }
  else if (!userScrolling) { isAutoScroll = false; }
});

window.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'l') {
    e.preventDefault();
    clearLog();
  }
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'c') {
    if (e.shiftKey) {
      e.preventDefault();
      copyLog();
    }
  }
});

window.addEventListener('load', () => {
  appendLine('[System] Terminal UI ready', 'system');
});
</script>




</body>
</html>
